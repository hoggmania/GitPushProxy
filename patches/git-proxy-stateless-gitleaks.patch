diff --git a/index.ts b/index.ts
index 433e8cd..c625f6f 100755
--- a/index.ts
+++ b/index.ts
@@ -7,7 +7,6 @@ import * as fs from 'fs';
 import { getConfigFile, setConfigFile, validate } from './src/config/file';
 import { initUserConfig } from './src/config';
 import { Proxy } from './src/proxy';
-import { Service } from './src/service';
 
 const argv = yargs(hideBin(process.argv))
   .usage('Usage: $0 [options]')
@@ -51,11 +50,7 @@ if (argv.v) {
 console.log('Validating config');
 validate();
 
-console.log('Setting up the proxy and Service');
-
-// The deferred imports should cause these to be loaded on first access
+console.log('Setting up stateless gitleaks proxy');
 const proxy = new Proxy();
 proxy.start();
-Service.start(proxy);
-
-export { proxy, Service };
+export { proxy };
diff --git a/src/proxy/chain.ts b/src/proxy/chain.ts
index b6c1b76..cdab7ee 100644
--- a/src/proxy/chain.ts
+++ b/src/proxy/chain.ts
@@ -1,33 +1,17 @@
 import { PluginLoader } from '../plugin';
 import { Action } from './actions';
 import * as proc from './processors';
-import { attemptAutoApproval, attemptAutoRejection } from './actions/autoActions';
 
 const pushActionChain: ((req: any, action: Action) => Promise<Action>)[] = [
   proc.push.parsePush,
-  proc.push.checkEmptyBranch,
-  proc.push.checkRepoInAuthorisedList,
-  proc.push.checkCommitMessages,
-  proc.push.checkAuthorEmails,
-  proc.push.checkUserPushPermission,
-  proc.push.pullRemote, // cleanup is handled after chain execution if successful
+  proc.push.pullRemote,
   proc.push.writePack,
-  proc.push.checkHiddenCommits,
-  proc.push.checkIfWaitingAuth,
-  proc.push.preReceive,
-  proc.push.getDiff,
   proc.push.gitleaks,
-  proc.push.scanDiff,
-  proc.push.blockForAuth,
 ];
 
-const pullActionChain: ((req: any, action: Action) => Promise<Action>)[] = [
-  proc.push.checkRepoInAuthorisedList,
-];
+const pullActionChain: ((req: any, action: Action) => Promise<Action>)[] = [];
 
-const defaultActionChain: ((req: any, action: Action) => Promise<Action>)[] = [
-  proc.push.checkRepoInAuthorisedList,
-];
+const defaultActionChain: ((req: any, action: Action) => Promise<Action>)[] = [];
 
 let pluginsInserted = false;
 
@@ -59,13 +43,6 @@ export const executeChain = async (req: any, res: any): Promise<Action> => {
       action = await proc.post.clearBareClone(req, action);
     }
 
-    action = await proc.post.audit(req, action);
-
-    if (action.autoApproved) {
-      await attemptAutoApproval(action);
-    } else if (action.autoRejected) {
-      await attemptAutoRejection(action);
-    }
   }
 
   return action;
diff --git a/src/proxy/index.ts b/src/proxy/index.ts
index 9f24e28..0de20dd 100644
--- a/src/proxy/index.ts
+++ b/src/proxy/index.ts
@@ -4,16 +4,13 @@ import https from 'https';
 import fs from 'fs';
 import { getRouter } from './routes';
 import {
-  getAuthorisedList,
   getPlugins,
   getTLSKeyPemPath,
   getTLSCertPemPath,
   getTLSEnabled,
 } from '../config';
-import { addUserCanAuthorise, addUserCanPush, createRepo, getRepos } from '../db';
 import { PluginLoader } from '../plugin';
 import chain from './chain';
-import { Repo } from '../db/types';
 import { serverConfig } from '../config/env';
 
 const { GIT_PROXY_SERVER_PORT: proxyHttpPort, GIT_PROXY_HTTPS_SERVER_PORT: proxyHttpsPort } =
@@ -57,18 +54,6 @@ export class Proxy {
     const pluginLoader = new PluginLoader(plugins);
     await pluginLoader.load();
     chain.chainPluginLoader = pluginLoader;
-    // Check to see if the default repos are in the repo list
-    const defaultAuthorisedRepoList = getAuthorisedList();
-    const allowedList: Repo[] = await getRepos();
-
-    for (const defaultRepo of defaultAuthorisedRepoList) {
-      const found = allowedList.find((configuredRepo) => configuredRepo.url === defaultRepo.url);
-      if (!found) {
-        const repo = await createRepo(defaultRepo);
-        await addUserCanPush(repo._id!, 'admin');
-        await addUserCanAuthorise(repo._id!, 'admin');
-      }
-    }
   }
 
   private async createApp() {
diff --git a/src/proxy/processors/post-processor/audit.ts b/src/proxy/processors/post-processor/audit.ts
index 32e556f..a274825 100644
--- a/src/proxy/processors/post-processor/audit.ts
+++ b/src/proxy/processors/post-processor/audit.ts
@@ -1,11 +1,7 @@
-import { writeAudit } from '../../../db';
 import { Action } from '../../actions';
 
 const exec = async (req: any, action: Action) => {
-  if (action.type !== 'pull') {
-    await writeAudit(action);
-  }
-
+  // Stateless mode: skip persistence.
   return action;
 };
 
diff --git a/src/proxy/routes/index.ts b/src/proxy/routes/index.ts
index ac53f0d..7aeb613 100644
--- a/src/proxy/routes/index.ts
+++ b/src/proxy/routes/index.ts
@@ -4,7 +4,6 @@ import { PassThrough } from 'stream';
 import getRawBody from 'raw-body';
 import { executeChain } from '../chain';
 import { processUrlPath, validGitRequest } from './helper';
-import { getAllProxiedHosts } from '../../db';
 import { ProxyOptions } from 'express-http-proxy';
 
 enum ActionType {
@@ -176,47 +175,18 @@ const getRouter = async () => {
   const router = Router();
   router.use(extractRawBody);
 
-  const originsToProxy = await getAllProxiedHosts();
-  const proxyKeys: string[] = [];
-  const proxies: RequestHandler[] = [];
-
-  console.log(`Initializing proxy router for origins: '${JSON.stringify(originsToProxy)}'`);
-
-  // we need to wrap multiple proxy middlewares in a custom middleware as middlewares
-  // with path are processed in descending path order (/ then /github.com etc.) and
-  // we want the fallback proxy to go last.
-  originsToProxy.forEach((origin) => {
-    console.log(`\tsetting up origin: '${origin}'`);
-
-    proxyKeys.push(`/${origin}/`);
-    proxies.push(
-      proxy('https://' + origin, {
-        parseReqBody: false,
-        preserveHostHdr: false,
-        filter: proxyFilter,
-        proxyReqPathResolver: getRequestPathResolver('https://'), // no need to add host as it's in the URL
-        proxyReqOptDecorator: proxyReqOptDecorator,
-        proxyReqBodyDecorator: proxyReqBodyDecorator,
-        proxyErrorHandler: proxyErrorHandler,
-        stream: true,
-      } as any),
-    );
-  });
-
-  console.log('\tsetting up catch-all route (github.com) for backwards compatibility');
+  console.log('Initializing stateless catch-all proxy route');
   const fallbackProxy: RequestHandler = proxy('https://github.com', {
     parseReqBody: false,
     preserveHostHdr: false,
     filter: proxyFilter,
-    proxyReqPathResolver: getRequestPathResolver('https://github.com'),
+    proxyReqPathResolver: getRequestPathResolver('https://'),
     proxyReqOptDecorator: proxyReqOptDecorator,
     proxyReqBodyDecorator: proxyReqBodyDecorator,
     proxyErrorHandler: proxyErrorHandler,
     stream: true,
   } as any);
 
-  console.log('proxy keys registered: ', JSON.stringify(proxyKeys));
-
   router.use('/', ((req, res, next) => {
     if (req.path === '/healthcheck') {
       res.set('Cache-Control', 'no-cache, no-store, must-revalidate, proxy-revalidate');
@@ -226,17 +196,6 @@ const getRouter = async () => {
       return res.status(200).send('OK');
     }
 
-    console.log(
-      `processing request URL: '${req.url}' against registered proxy keys: ${JSON.stringify(proxyKeys)}`,
-    );
-
-    for (let i = 0; i < proxyKeys.length; i++) {
-      if (req.url.startsWith(proxyKeys[i])) {
-        console.log(`\tusing proxy ${proxyKeys[i]}`);
-        return proxies[i](req, res, next);
-      }
-    }
-    // fallback
     console.log(`\tusing fallback`);
     return fallbackProxy(req, res, next);
   }) as RequestHandler);
